<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class OpenSSL::PKey::RSA - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/darkfish.js"></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="PKey.html">OpenSSL::PKey::PKey</a>
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-generate">::generate</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-blinding_off-21">#blinding_off!</a>
    
    <li ><a href="#method-i-blinding_on-21">#blinding_on!</a>
    
    <li ><a href="#method-i-export">#export</a>
    
    <li ><a href="#method-i-params">#params</a>
    
    <li ><a href="#method-i-private-3F">#private?</a>
    
    <li ><a href="#method-i-private_decrypt">#private_decrypt</a>
    
    <li ><a href="#method-i-private_encrypt">#private_encrypt</a>
    
    <li ><a href="#method-i-public-3F">#public?</a>
    
    <li ><a href="#method-i-public_decrypt">#public_decrypt</a>
    
    <li ><a href="#method-i-public_encrypt">#public_encrypt</a>
    
    <li ><a href="#method-i-public_key">#public_key</a>
    
    <li ><a href="#method-i-set_crt_params">#set_crt_params</a>
    
    <li ><a href="#method-i-set_factors">#set_factors</a>
    
    <li ><a href="#method-i-set_key">#set_key</a>
    
    <li ><a href="#method-i-to_der">#to_der</a>
    
    <li ><a href="#method-i-to_pem">#to_pem</a>
    
    <li ><a href="#method-i-to_s">#to_s</a>
    
    <li ><a href="#method-i-to_text">#to_text</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-OpenSSL::PKey::RSA">
  <h1 id="class-OpenSSL::PKey::RSA" class="class">
    class OpenSSL::PKey::RSA
  </h1>

  <section class="description">
    
<p><a href="RSA.html">RSA</a> is an asymmetric public key algorithm that has
been formalized in RFC 3447. It is in widespread use in public key
infrastuctures (PKI) where certificates (cf. <a
href="../X509/Certificate.html">OpenSSL::X509::Certificate</a>) often are
issued on the basis of a public/private <a href="RSA.html">RSA</a> key
pair. <a href="RSA.html">RSA</a> is used in a wide field of applications
such as secure (symmetric) key exchange, e.g. when establishing a secure
TLS/SSL connection. It is also used in various digital signature schemes.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-generate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            generate(size)           &rarr; RSA instance
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            generate(size, exponent) &rarr; RSA instance
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generates an <a href="RSA.html">RSA</a> keypair.  <code>size</code> is an
integer representing the desired key size.  Keys smaller than 1024 should
be considered insecure.  <code>exponent</code> is an odd number normally 3,
17, or 65537.</p>
          
          

          
          <div class="method-source-code" id="generate-source">
            <pre>static VALUE
ossl_rsa_s_generate(int argc, VALUE *argv, VALUE klass)
{
/* why does this method exist?  why can&#39;t initialize take an optional exponent? */
    RSA *rsa;
    VALUE size, exp;
    VALUE obj;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;size, &amp;exp);

    rsa = rsa_generate(NUM2INT(size), NIL_P(exp) ? RSA_F4 : NUM2ULONG(exp)); /* err handled by rsa_instance */
    obj = rsa_instance(klass, rsa);

    if (obj == Qfalse) {
        RSA_free(rsa);
        ossl_raise(eRSAError, NULL);
    }

    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            new(key_size)                 &rarr; RSA instance
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(encoded_key)              &rarr; RSA instance
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(encoded_key, pass_phrase) &rarr; RSA instance
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generates or loads an <a href="RSA.html">RSA</a> keypair.  If an integer
<code>key_size</code> is given it represents the desired key size.  Keys
less than 1024 bits should be considered insecure.</p>

<p>A key can instead be loaded from an <code>encoded_key</code> which must be
PEM or DER encoded.  A <code>pass_phrase</code> can be used to decrypt the
key.  If none is given <a href="../../OpenSSL.html">OpenSSL</a> will prompt
for the pass phrase.</p>

<h1 id="method-c-new-label-Examples">Examples<span><a href="#method-c-new-label-Examples">&para;</a> <a href="#top">&uarr;</a></span></h1>

<pre class="ruby"><span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">PKey</span><span class="ruby-operator">::</span><span class="ruby-constant">RSA</span>.<span class="ruby-identifier">new</span> <span class="ruby-value">2048</span>
<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">PKey</span><span class="ruby-operator">::</span><span class="ruby-constant">RSA</span>.<span class="ruby-identifier">new</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span> <span class="ruby-string">&#39;rsa.pem&#39;</span>
<span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">PKey</span><span class="ruby-operator">::</span><span class="ruby-constant">RSA</span>.<span class="ruby-identifier">new</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-string">&#39;rsa.pem&#39;</span>), <span class="ruby-string">&#39;my pass phrase&#39;</span>
</pre>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE
ossl_rsa_initialize(int argc, VALUE *argv, VALUE self)
{
    EVP_PKEY *pkey;
    RSA *rsa;
    BIO *in;
    VALUE arg, pass;

    GetPKey(self, pkey);
    if(rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg, &amp;pass) == 0) {
        rsa = RSA_new();
    }
    else if (RB_INTEGER_TYPE_P(arg)) {
        rsa = rsa_generate(NUM2INT(arg), NIL_P(pass) ? RSA_F4 : NUM2ULONG(pass));
        if (!rsa) ossl_raise(eRSAError, NULL);
    }
    else {
        pass = ossl_pem_passwd_value(pass);
        arg = ossl_to_der_if_possible(arg);
        in = ossl_obj2bio(arg);
        rsa = PEM_read_bio_RSAPrivateKey(in, NULL, ossl_pem_passwd_cb, (void *)pass);
        if (!rsa) {
            OSSL_BIO_reset(in);
            rsa = PEM_read_bio_RSA_PUBKEY(in, NULL, NULL, NULL);
        }
        if (!rsa) {
            OSSL_BIO_reset(in);
            rsa = d2i_RSAPrivateKey_bio(in, NULL);
        }
        if (!rsa) {
            OSSL_BIO_reset(in);
            rsa = d2i_RSA_PUBKEY_bio(in, NULL);
        }
        if (!rsa) {
            OSSL_BIO_reset(in);
            rsa = PEM_read_bio_RSAPublicKey(in, NULL, NULL, NULL);
        }
        if (!rsa) {
            OSSL_BIO_reset(in);
            rsa = d2i_RSAPublicKey_bio(in, NULL);
        }
        BIO_free(in);
        if (!rsa) {
            ossl_raise(eRSAError, &quot;Neither PUB key nor PRIV key&quot;);
        }
    }
    if (!EVP_PKEY_assign_RSA(pkey, rsa)) {
        RSA_free(rsa);
        ossl_raise(eRSAError, NULL);
    }

    return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-blinding_off-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">blinding_off!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="blinding_off-21-source">
            <pre>static VALUE
ossl_rsa_blinding_off(VALUE self)
{
    RSA *rsa;

    GetRSA(self, rsa);
    RSA_blinding_off(rsa);

    return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-blinding_on-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">blinding_on!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="blinding_on-21-source">
            <pre>static VALUE
ossl_rsa_blinding_on(VALUE self)
{
    RSA *rsa;

    GetRSA(self, rsa);

    if (RSA_blinding_on(rsa, ossl_bn_ctx) != 1) {
        ossl_raise(eRSAError, NULL);
    }
    return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-export" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            export([cipher, pass_phrase]) &rarr; PEM-format String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_pem([cipher, pass_phrase]) &rarr; PEM-format String
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_s([cipher, pass_phrase]) &rarr; PEM-format String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Outputs this keypair in PEM encoding.  If <code>cipher</code> and
<code>pass_phrase</code> are given they will be used to encrypt the key. 
<code>cipher</code> must be an <a href="../Cipher.html">OpenSSL::Cipher</a>
instance.</p>
          
          

          
          <div class="method-source-code" id="export-source">
            <pre>static VALUE
ossl_rsa_export(int argc, VALUE *argv, VALUE self)
{
    RSA *rsa;
    BIO *out;
    const EVP_CIPHER *ciph = NULL;
    VALUE cipher, pass, str;

    GetRSA(self, rsa);

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;cipher, &amp;pass);

    if (!NIL_P(cipher)) {
        ciph = GetCipherPtr(cipher);
        pass = ossl_pem_passwd_value(pass);
    }
    if (!(out = BIO_new(BIO_s_mem()))) {
        ossl_raise(eRSAError, NULL);
    }
    if (RSA_HAS_PRIVATE(rsa)) {
        if (!PEM_write_bio_RSAPrivateKey(out, rsa, ciph, NULL, 0,
                                         ossl_pem_passwd_cb, (void *)pass)) {
            BIO_free(out);
            ossl_raise(eRSAError, NULL);
        }
    } else {
        if (!PEM_write_bio_RSA_PUBKEY(out, rsa)) {
            BIO_free(out);
            ossl_raise(eRSAError, NULL);
        }
    }
    str = ossl_membio2str(out);

    return str;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="RSA.html#method-i-to_pem">to_pem</a>, <a href="RSA.html#method-i-to_s">to_s</a>
        </div>
        

        
      </div>

    
      <div id="method-i-params" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            params &rarr; hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!</p>

<p>Stores all parameters of key to the hash.  The hash has keys &#39;n&#39;,
&#39;e&#39;, &#39;d&#39;, &#39;p&#39;, &#39;q&#39;, &#39;dmp1&#39;,
&#39;dmq1&#39;, &#39;iqmp&#39;.</p>

<p>Don&#39;t use :-)) (It&#39;s up to you)</p>
          
          

          
          <div class="method-source-code" id="params-source">
            <pre>static VALUE
ossl_rsa_get_params(VALUE self)
{
    RSA *rsa;
    VALUE hash;
    const BIGNUM *n, *e, *d, *p, *q, *dmp1, *dmq1, *iqmp;

    GetRSA(self, rsa);
    RSA_get0_key(rsa, &amp;n, &amp;e, &amp;d);
    RSA_get0_factors(rsa, &amp;p, &amp;q);
    RSA_get0_crt_params(rsa, &amp;dmp1, &amp;dmq1, &amp;iqmp);

    hash = rb_hash_new();
    rb_hash_aset(hash, rb_str_new2(&quot;n&quot;), ossl_bn_new(n));
    rb_hash_aset(hash, rb_str_new2(&quot;e&quot;), ossl_bn_new(e));
    rb_hash_aset(hash, rb_str_new2(&quot;d&quot;), ossl_bn_new(d));
    rb_hash_aset(hash, rb_str_new2(&quot;p&quot;), ossl_bn_new(p));
    rb_hash_aset(hash, rb_str_new2(&quot;q&quot;), ossl_bn_new(q));
    rb_hash_aset(hash, rb_str_new2(&quot;dmp1&quot;), ossl_bn_new(dmp1));
    rb_hash_aset(hash, rb_str_new2(&quot;dmq1&quot;), ossl_bn_new(dmq1));
    rb_hash_aset(hash, rb_str_new2(&quot;iqmp&quot;), ossl_bn_new(iqmp));

    return hash;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-private-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            private? &rarr; true | false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Does this keypair contain a private key?</p>
          
          

          
          <div class="method-source-code" id="private-3F-source">
            <pre>static VALUE
ossl_rsa_is_private(VALUE self)
{
    RSA *rsa;

    GetRSA(self, rsa);

    return RSA_PRIVATE(self, rsa) ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-private_decrypt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            private_decrypt(string)          &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            private_decrypt(string, padding) &rarr; String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Decrypt <code>string</code>, which has been encrypted with the public key,
with the private key.  <code>padding</code> defaults to PKCS1_PADDING.</p>
          
          

          
          <div class="method-source-code" id="private_decrypt-source">
            <pre>static VALUE
ossl_rsa_private_decrypt(int argc, VALUE *argv, VALUE self)
{
    RSA *rsa;
    const BIGNUM *rsa_n;
    int buf_len, pad;
    VALUE str, buffer, padding;

    GetRSA(self, rsa);
    RSA_get0_key(rsa, &amp;rsa_n, NULL, NULL);
    if (!rsa_n)
        ossl_raise(eRSAError, &quot;incomplete RSA&quot;);
    if (!RSA_PRIVATE(self, rsa))
        ossl_raise(eRSAError, &quot;private key needed.&quot;);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;buffer, &amp;padding);
    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
    StringValue(buffer);
    str = rb_str_new(0, RSA_size(rsa));
    buf_len = RSA_private_decrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
                                  (unsigned char *)RSTRING_PTR(str), rsa, pad);
    if (buf_len &lt; 0) ossl_raise(eRSAError, NULL);
    rb_str_set_len(str, buf_len);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-private_encrypt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            private_encrypt(string)          &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            private_encrypt(string, padding) &rarr; String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Encrypt <code>string</code> with the private key.  <code>padding</code>
defaults to PKCS1_PADDING. The encrypted string output can be decrypted
using <a href="RSA.html#method-i-public_decrypt">public_decrypt</a>.</p>
          
          

          
          <div class="method-source-code" id="private_encrypt-source">
            <pre>static VALUE
ossl_rsa_private_encrypt(int argc, VALUE *argv, VALUE self)
{
    RSA *rsa;
    const BIGNUM *rsa_n;
    int buf_len, pad;
    VALUE str, buffer, padding;

    GetRSA(self, rsa);
    RSA_get0_key(rsa, &amp;rsa_n, NULL, NULL);
    if (!rsa_n)
        ossl_raise(eRSAError, &quot;incomplete RSA&quot;);
    if (!RSA_PRIVATE(self, rsa))
        ossl_raise(eRSAError, &quot;private key needed.&quot;);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;buffer, &amp;padding);
    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
    StringValue(buffer);
    str = rb_str_new(0, RSA_size(rsa));
    buf_len = RSA_private_encrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
                                  (unsigned char *)RSTRING_PTR(str), rsa, pad);
    if (buf_len &lt; 0) ossl_raise(eRSAError, NULL);
    rb_str_set_len(str, buf_len);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-public-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            public? &rarr; true
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The return value is always true since every private key is also a public
key.</p>
          
          

          
          <div class="method-source-code" id="public-3F-source">
            <pre>static VALUE
ossl_rsa_is_public(VALUE self)
{
    RSA *rsa;

    GetRSA(self, rsa);
    /*
     * This method should check for n and e.  BUG.
     */
    (void)rsa;
    return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-public_decrypt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            public_decrypt(string)          &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            public_decrypt(string, padding) &rarr; String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Decrypt <code>string</code>, which has been encrypted with the private key,
with the public key.  <code>padding</code> defaults to PKCS1_PADDING.</p>
          
          

          
          <div class="method-source-code" id="public_decrypt-source">
            <pre>static VALUE
ossl_rsa_public_decrypt(int argc, VALUE *argv, VALUE self)
{
    RSA *rsa;
    const BIGNUM *rsa_n;
    int buf_len, pad;
    VALUE str, buffer, padding;

    GetRSA(self, rsa);
    RSA_get0_key(rsa, &amp;rsa_n, NULL, NULL);
    if (!rsa_n)
        ossl_raise(eRSAError, &quot;incomplete RSA&quot;);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;buffer, &amp;padding);
    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
    StringValue(buffer);
    str = rb_str_new(0, RSA_size(rsa));
    buf_len = RSA_public_decrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
                                 (unsigned char *)RSTRING_PTR(str), rsa, pad);
    if (buf_len &lt; 0) ossl_raise(eRSAError, NULL);
    rb_str_set_len(str, buf_len);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-public_encrypt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            public_encrypt(string)          &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            public_encrypt(string, padding) &rarr; String
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Encrypt <code>string</code> with the public key.  <code>padding</code>
defaults to PKCS1_PADDING. The encrypted string output can be decrypted
using <a href="RSA.html#method-i-private_decrypt">private_decrypt</a>.</p>
          
          

          
          <div class="method-source-code" id="public_encrypt-source">
            <pre>static VALUE
ossl_rsa_public_encrypt(int argc, VALUE *argv, VALUE self)
{
    RSA *rsa;
    const BIGNUM *rsa_n;
    int buf_len, pad;
    VALUE str, buffer, padding;

    GetRSA(self, rsa);
    RSA_get0_key(rsa, &amp;rsa_n, NULL, NULL);
    if (!rsa_n)
        ossl_raise(eRSAError, &quot;incomplete RSA&quot;);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;buffer, &amp;padding);
    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
    StringValue(buffer);
    str = rb_str_new(0, RSA_size(rsa));
    buf_len = RSA_public_encrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
                                 (unsigned char *)RSTRING_PTR(str), rsa, pad);
    if (buf_len &lt; 0) ossl_raise(eRSAError, NULL);
    rb_str_set_len(str, buf_len);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-public_key" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            public_key &rarr; RSA
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Makes new <a href="RSA.html">RSA</a> instance containing the public key
from the private key.</p>
          
          

          
          <div class="method-source-code" id="public_key-source">
            <pre>static VALUE
ossl_rsa_to_public_key(VALUE self)
{
    EVP_PKEY *pkey;
    RSA *rsa;
    VALUE obj;

    GetPKeyRSA(self, pkey);
    /* err check performed by rsa_instance */
    rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(pkey));
    obj = rsa_instance(rb_obj_class(self), rsa);
    if (obj == Qfalse) {
        RSA_free(rsa);
        ossl_raise(eRSAError, NULL);
    }
    return obj;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-set_crt_params" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_crt_params(dmp1, dmq1, iqmp) &rarr; self
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets <code>dmp1</code>, <code>dmq1</code>, <code>iqmp</code> for the <a
href="RSA.html">RSA</a> instance. They are calculated by <code>d mod (p -
1)</code>, <code>d mod (q - 1)</code> and <code>q^(-1) mod p</code>
respectively.</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-i-set_factors" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_factors(p, q) &rarr; self
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets <code>p</code>, <code>q</code> for the <a href="RSA.html">RSA</a>
instance.</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-i-set_key" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            set_key(n, e, d) &rarr; self
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets <code>n</code>, <code>e</code>, <code>d</code> for the <a
href="RSA.html">RSA</a> instance.</p>
          
          

          
        </div>

        

        
      </div>

    
      <div id="method-i-to_der" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_der &rarr; DER-format String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Outputs this keypair in DER encoding.</p>
          
          

          
          <div class="method-source-code" id="to_der-source">
            <pre>static VALUE
ossl_rsa_to_der(VALUE self)
{
    RSA *rsa;
    int (*i2d_func)(const RSA *, unsigned char **);
    unsigned char *p;
    long len;
    VALUE str;

    GetRSA(self, rsa);
    if (RSA_HAS_PRIVATE(rsa))
        i2d_func = i2d_RSAPrivateKey;
    else
        i2d_func = (int (*)(const RSA *, unsigned char **))i2d_RSA_PUBKEY;
    if((len = i2d_func(rsa, NULL)) &lt;= 0)
        ossl_raise(eRSAError, NULL);
    str = rb_str_new(0, len);
    p = (unsigned char *)RSTRING_PTR(str);
    if(i2d_func(rsa, &amp;p) &lt; 0)
        ossl_raise(eRSAError, NULL);
    ossl_str_adjust(str, p);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_pem" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_pem</span><span
            class="method-args">(p1 = v1, p2 = v2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="RSA.html#method-i-export">export</a>
        </div>
        
      </div>

    
      <div id="method-i-to_s" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_s</span><span
            class="method-args">(p1 = v1, p2 = v2)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="RSA.html#method-i-export">export</a>
        </div>
        
      </div>

    
      <div id="method-i-to_text" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_text &rarr; String
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!</p>

<p>Dumps all parameters of a keypair to a String</p>

<p>Don&#39;t use :-)) (It&#39;s up to you)</p>
          
          

          
          <div class="method-source-code" id="to_text-source">
            <pre>static VALUE
ossl_rsa_to_text(VALUE self)
{
    RSA *rsa;
    BIO *out;
    VALUE str;

    GetRSA(self, rsa);
    if (!(out = BIO_new(BIO_s_mem()))) {
        ossl_raise(eRSAError, NULL);
    }
    if (!RSA_print(out, rsa, 0)) { /* offset = 0 */
        BIO_free(out);
        ossl_raise(eRSAError, NULL);
    }
    str = ossl_membio2str(out);

    return str;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://rdoc.github.io/rdoc">RDoc</a> 5.0.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

